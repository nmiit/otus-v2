1. ingress-nginx

Добавлять ingress-nginx как зависимость не рекомендуется в продакшене.
Это нарушает принципы разделения зон ответственности и приводит к дублированию.
Лучше установить контроллер один раз, а приложения просто подключать к нему через Ingress.
Если мне понадобится сделать ещё один или несколько чартов, этот момент стоит учесть и переделать.

-----------------------------------------------------------------------------------------------------------------------

2. PVC, PV и StorageClass

На основе шаблона volumeClaimTemplates в postgres-statefulset.yaml, при создании поды (например, postgres-0, postgres-1, ...),
для каждого пода автоматически создаётся PersistentVolumeClaim (PVC).
PV создаётся автоматически на основе storageclass и provisioner и что в кластере по умолчанию включена Dynamic Volume Provisioning.

$ kubectl get storageclass - покажет все storageclass кластера.
standard - создаётся миникубом по умолчанию.
postgres-sc - наш кастомный storageclass с изменёнными параметрами (realPolicy и allowVolumeExpansion).

Параметр realPolicy: Retain - после удаления PVC, PV остаётся в статусе Released и не удаляется,
чтобы данные сохранились, и с ними можно было бы как то взаимодействовать.

Параметр provisioner: k8s.io/minikube-hostpath - использует провайдер для хостинга на миникубе. Для прода его нужно изменить.
provisioner: kubernetes.io/aws-ebs # ← провайдер: зависит от облака

Параметр volumeBindingMode: Immediate - это настройка связки PV и PVC. Immediate - это быстрая связка без зонирования.
Для продакшена с облачными дисками (AWS EBS, GCP PD) — нужно использовать volumeBindingMode: WaitForFirstConsumer

Параметр allowVolumeExpansion: true в StorageClass — это возможность увеличить размер PersistentVolume (PV) "на лету",
то есть без удаления PVC и потери данных.
$ kubectl edit pvc postgres-storage-postgres-0 - вызываем, и редактируем PVC изменяя storage например.

-----------------------------------------------------------------------------------------------------------------------

auth

Для авторизации в Grafana добавлен файл auth.
https://hostingcanada.org/htpasswd-generator/#password - тут вбиваем нужный вам для графаны логин и пароль,
генерируем секрет и вставляем его в файл auth (admin/password123).
Выполняем $ kubectl create secret generic grafana-basic-auth --from-file=auth

-----------------------------------------------------------------------------------------------------------------------

kube-prometheus-stack

В Chart.yaml была добавлена зависимость на kube-prometheus-stack.
Это Helm-чарт, который включает в себя Prometheus Operator + готовый набор компонентов: Prometheus, Grafana, Alertmanager, дашборды, алерты и т.д.
Prometheus Operator управляет жизненным циклом экземпляров Prometheus и Alertmanager (создание, обновление, масштабирование).
Сам по себе не разворачивает Prometheus или Grafana — он только управляет ими, если они объявлены.

-----------------------------------------------------------------------------------------------------------------------

ServiceMonitor.yaml

spec.selector.matchLabels - Указывает, какие сервисы нужно мониторить — а именно те, у которых есть определённые метки (labels).
spec.endpoints.path: /actuator/prometheus - Указывает путь, по которому доступны метрики в формате Prometheus.
interval: 15s - Как часто Prometheus будет забирать метрики (по умолчанию обычно 30с).
namespaceSelector.matchNames - Ограничивает сбор метрик только тем namespace, где установлен релиз Helm.

-----------------------------------------------------------------------------------------------------------------------

livenessProbe, readinessProbe, startupProbe

В файл app-deployment.yaml добавлены пробы.
livenessProbe — проверяет, «живо» ли приложение. При сбое контейнер будет перезапущен.
readinessProbe — определяет, готово ли приложение принимать трафик. Если провалена — Pod удаляется из Endpoints Service.
startupProbe — отключает остальные пробы до тех пор, пока приложение не запустится. Полезно для медленно стартующих приложений.

-----------------------------------------------------------------------------------------------------------------------

kong

Добавляем в приложение авторизацию, а в helm чарте заменяем Nginx на Kong.

api/auth/register - создаёт пользователей (конг пропускает без проверки)
api/auth/login - аутентификация пользователей (конг пропускает без проверки)
api/ - остальные api запросы конг без проверки валидности jwt токена не пропустит до приложения
Запросы на прометеус и графана конг пропускает без проверки (/actuator/prometheus, /testkuber.grafana)

Для всего вышеперечисленного создано 2 kong-ingress манифеста. Один публичный (пропус запросов без проверок), другой защищённый.

Проверка jwt происходит за счёт KongPlugin. Публичный ключ для проверки передаём через Secret и KongConsumer.